input { 
  udp { #méthode de transfert par défaut du pfSense
    port => 5001 #port d'écoute ouvert dans notre configuration docker-compose
  }
}

filter {
  if [message] =~ /udp/ {
    grok {
      match => {
        "message" => "<134>1\s+%{YEAR:Year}-%{MONTHNUM2:Month}-%{MONTHDAY:Day}T%{HOUR:Hour}:%{MINUTE:Minutes}:%{SECOND:Secondes}%{ISO8601_TIMEZONE:UTC}\s%{HOSTNAME:hostname}\s%{PROG:appname}\s%{POSINT:processID}\s-\s-\s%{INT:rule_number},,,%{INT:tracker},%{WORD:interface_reseau},%{WORD:reason},%{WORD:action},%{WORD:direction},%{NUMBER:ip_version},%{BASE16NUM:TOS},,%{INT:TTL},%{INT:ID},%{INT:offset},%{WORD:flags},%{INT:protocol_id},%{WORD:protocol},%{INT:length_bytes},%{IPV4:ip_src},%{IPV4:ip_dst},%{POSINT:port_src},%{POSINT:port_dst},%{POSINT:data_length}"
      }
    }
  } else if [message] =~ /tcp/ {
    grok {
      match => {
        "message" => "<134>1\s+%{YEAR:Year}-%{MONTHNUM2:Month}-%{MONTHDAY:Day}T%{HOUR:Hour}:%{MINUTE:Minutes}:%{SECOND:Secondes}%{ISO8601_TIMEZONE:UTC}\s%{HOSTNAME:hostname}\s%{PROG:appname}\s%{POSINT:processID}\s-\s-\s%{INT:rule_number},,,%{INT:tracker},%{WORD:interface_reseau},%{WORD:reason},%{WORD:action},%{WORD:direction},%{NUMBER:ip_version},%{BASE16NUM:TOS},,%{INT:TTL},%{INT:ID},%{INT:offset},%{WORD:flags},%{INT:protocol_id},%{WORD:protocol},%{INT:length_bytes},%{IPV4:ip_src},%{IPV4:ip_dst},%{POSINT:port_src},%{POSINT:port_dst},%{INT:data_length},%{WORD:tcp_flags},%{INT:sequence_number},,%{INT:tcp_window},,%{GREEDYDATA:tcp_option}"
      }
    }
  }
}

output {
  elasticsearch {
    index => "pfsense-%{+YYYY.MM.dd}" #nommage de l'index 
    hosts=> "${ELASTIC_HOSTS}"
    user=> "${ELASTIC_USER}"
    password=> "${ELASTIC_PASSWORD}"
    cacert=> "certs/ca/ca.crt"
  }
}